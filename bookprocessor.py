from bs4 import BeautifulSoup, NavigableString,Tag
from zipfile import ZipFile, ZIP_DEFLATED
import re
import shutil
from threadedconvert import ThreadedConvert
import sys
import time

class ConversionEngine(object):

    def convert(self, text):
        raise NotImplementedError("Conversion Engine must be subclassed")


class BookProcessor(object):

    def __init__(self, conversion_engine, progress_callback=None, test=False):
        self._conversion_engine = conversion_engine
        self._callback = progress_callback
        self._test = test
        self._mode = "paragraph"

    def set_file(self, src_file, dest_file=None):
        self._filepath = src_file
        self._destfile = dest_file

    def get_html_files_ref(self):
        htmlfiles = []

        with ZipFile(self._filepath, 'r') as f:
            with f.open('META-INF/container.xml') as foo:
                soup = BeautifulSoup(foo, features='xml')
                contentfile = dict(soup.find('rootfile').attrs)['full-path']

            root = re.sub(r'[^/]*(.opf)', '', contentfile)

            with f.open(contentfile) as foo:
                soup = BeautifulSoup(foo, features='xml')
                for item in soup.findAll('item'):
                    itemdict = dict(item.attrs)
                    if itemdict['href'].endswith('html'):
                        htmlfiles.append(root + itemdict['href'])

        return htmlfiles

    def get_converted_html_by_sentence(self, soup):
        for pTag in soup.findAll( {'p' : True}):
            #only support calibre-converted ebook, for NOW
            if pTag['class'] != 'calibre':
                continue
            new_content = u''
            for content in pTag.contents:
                if type(content) is NavigableString:
                    new_content = new_content + content
                elif content.name == "ruby" :
                    for ruby_char in content.contents:
                        #ignore <rt>
                        if type(ruby_char) is NavigableString:
                            new_content = new_content + ruby_char
            

            #print(new_content)
            #continue
            # new_content is a sentence. send it to Google translate
            try:
                en_text = self._conversion_engine.convert(new_content)        
            except Exception as err:
                en_text = "TRANSLATE ERROR"
                print(err)
                print(new_content)
                print("is this book generated by calibre?")
 
            if len(new_content) >0:
                br1 = soup.new_tag("br")
                br2 = soup.new_tag("br")
                idx = len(pTag.contents)
                pTag.insert(idx, br1)
                pTag.insert(idx+1, NavigableString("&emsp;" + en_text))
                pTag.insert(idx+2, br2)

        return soup.encode(formatter=None).decode()


    def get_converted_html(self, soup):
        if self._mode == "sentence":
            return self.get_converted_html_by_sentence(soup)
        else:
            return self.get_converted_html_by_paragraph(soup)

    def get_converted_html_by_paragraph(self, soup):
        #remote note for Chinese charactors: Tag <rt>
        #for nstring in soup.findAll( {'rt' : True}):
        #    nstring.extract()
        total_content = u''
        total_len = 0
        #remove tag <ruby> but keep the char inside
        p_tags = soup.findAll( {'p' : True})

        for i, pTag in enumerate(p_tags):
            #only support calibre-converted ebook, for NOW
            if pTag['class'] != 'calibre':
                continue
            new_content = u''
            for content in pTag.contents:
                if type(content) is NavigableString:
                    new_content = new_content + content
                elif content.name == "ruby" :
                    for ruby_char in content.contents:
                        #ignore <rt>
                        if type(ruby_char) is NavigableString:
                            new_content = new_content + ruby_char
            
            total_content = total_content + "\n" + new_content
            total_len = total_len + len(new_content)

            is_last = (i == len(p_tags) - 1)
            if total_len < 4096 and not is_last:
                continue
            
            print(total_content)
            #continue
            # new_content is a sentence. send it to Google translate
            try:
                en_text = self._conversion_engine.convert(total_content)        
            except Exception as err:
                en_text = "TRANSLATE ERROR"
                print(err)
                print(total_content)
                print("is this book generated by calibre?")
 
            total_content = ""
            total_len = 0

            if len(en_text) >0:
                output_test = en_text.split("\n")
                for line in output_test:
                    if len(line) > 0:
                        br1 = soup.new_tag("br")
                        br2 = soup.new_tag("br")
                        idx = len(pTag.contents)
                        pTag.insert(idx, br1)
                        pTag.insert(idx+1, NavigableString("&emsp;" + line))
                        pTag.insert(idx+2, br2)

        return soup.encode(formatter=None).decode()

    def convert_css(self, css_file_path):
        """Convert CSS from vertical layout to horizontal layout"""
        print(css_file_path)
        try:
            with ZipFile(self._destfile, 'r') as f:
                with f.open(css_file_path) as css_file:
                    css_content = css_file.read().decode('utf-8')
            
            # Apply horizontal layout modifications
            modified_css = self._apply_horizontal_layout(css_content)
            
            # Write back to the zip file
            with ZipFile(self._destfile, 'a', ZIP_DEFLATED) as f:
                f.writestr(css_file_path, modified_css.encode('utf-8'))
                
        except Exception as e:
            print(f"Error converting CSS file {css_file_path}: {e}")
    
    def _apply_horizontal_layout(self, css_content):
        """Apply horizontal layout modifications to CSS content"""
        # Replace vertical writing modes with horizontal
        css_content = re.sub(
            r'-webkit-writing-mode:\s*vertical-rl;',
            'writing-mode: horizontal-tb;\n  -webkit-writing-mode: horizontal-tb;',
            css_content
        )
        
        # Add standard writing-mode property where only webkit version exists
        css_content = re.sub(
            r'(-webkit-writing-mode:\s*horizontal-tb;)',
            r'writing-mode: horizontal-tb;\n  \1',
            css_content
        )
        
        # Improve paragraph styling for horizontal reading
        css_content = re.sub(
            r'\.calibre\s*\{([^}]*)\}',
            self._enhance_calibre_style,
            css_content,
            flags=re.DOTALL
        )
        print(css_content)
        return css_content
    
    def _enhance_calibre_style(self, match):
        """Enhance .calibre style for horizontal reading"""
        style_content = match.group(1)
        
        # Add horizontal reading enhancements if not already present
        if 'text-indent' not in style_content:
            style_content = style_content.rstrip() + '\n  text-indent: 1.5em;'
        if 'line-height' not in style_content:
            style_content = style_content.rstrip() + '\n  line-height: 1.6;'
            
        return f'.calibre {{{style_content}}}'

    def convert(self, mode="paragraph"):
        self._mode = mode

        if self._destfile is None or self._filepath == self._destfile:
            self._destfile = self._filepath
        else:
            shutil.copyfile(self._filepath, self._destfile)

        htmls = self.get_html_files_ref()

        if self._callback:
            self._callback.update_state("total", len(htmls))

        # First, process CSS files
        with ZipFile(self._destfile, 'r') as f:
             for item in f.filelist:
                #print(item)
                if item.filename.find("stylesheet.css") != -1:
                    self.convert_css(item)
        
        # Then process HTML files
        with ZipFile(self._destfile, 'a', ZIP_DEFLATED) as f:
            threads = []
            for item in htmls:
                #only for calibre epub
                if item.find("text/") == -1:
                    continue
                if self._test and item.find("part0005_split_000.html") == -1:
                    continue

                t = ThreadedConvert(self, item, f, self._callback)
                t.start()
                #wait for finish. Do not use multi thread feature, OR your ip will be BANNED !
                t.join()
                #threads.append(t)

            #for t in threads:
            #    t.join()

        if self._callback:
            self._callback.update_state("complete")